\section{Dead code elimination}

The use of dead code elimination can be seen more as a garbage collector. In most cases, the programmer will not leave behind code which is not in use and therefore this transformation will not have anything to do. However, as soon as another analysis have transformed the code in some way, for example constant propagation which substitutes variables with their constant value if possible, there will most likely be some variables left behind which now have no effect. Or, if they have an effect, it will be on other variables which does not have any effect on whatever is returned or is considered ``interesting''.

Dead code elimination is based upon the result of live variable analysis, however in this case it is strongly live variable analysis, which it uses to determine if a line of code is alive or not. If the code is alive, it has an effect on whatever the code will output as result, and that would be changed if the line were removed. If the line is not alive, the code could be removed without having any effect on the output.

Lets take an exampleÂ¸ here is some code:
\begin{lstlisting}
module dead_code_elimination_example :
	read d;
	read i;
	i := 2;
	a := a + 1;
	if i > d -> i := i + a;f := 2 * 6; d := e - 1
	[] i = d -> e := 0; i := a * 2; a := i * i
	[] i < d -> abort
	fi;
	f := 2 + f;
	i := d * e * a + d + 1 * 10;
	d := a * a + d + i;
	i := d + i * e;
	d := e * a;
	f := 5;
	write a
end
\end{lstlisting}
Our version of live variable analysis will have concluded, that the only interesting variable is a. The variable a is written in the end, so it will automaticly be seen as alive and therefore should be kept after the transformation. The variable a might be used to assign a value to other satements, however none of them have any effect on a. This means, that all the assign statement between the if-statement and "write a" can be removed.
\begin{lstlisting}
module dead_code_elimination_example :
	read d;
	read i;
	i := 2;
	a := a + 1;
	if i > d -> i := i + a;f := 2 * 6; d := e - 1
	[] i = d -> e := 0; i := a * 2; a := i * i
	[] i < d -> abort
	fi;
	write a
end
\end{lstlisting}
Inside the if-statement, the variable i now has an effect on a because it is part of the assign statement of a, so i is also considered alive (even though e is inside the same branch as i and a, it is not considered interesting and alive since it have no effect on any of them). Because of this, the condition for that branch is now having an effect, so d also has an effect on i and a (if d were anything else than equal to i, this branch would not be used).

The transformation of an if-statement is not as easy as the simple assignments which came after the if-statement, different rules applies. Live variable analysis do not contain enough information to safely determine, if a branch is ever reached. That requires knowing the value of i and d, which is not something which concerns live variable analysis. Because of that, all the conditions have to be preserved, even though they contain variables which are not alive (in our case they are considered alive). Every variable in any condition is now considered alive. The set of statements which the conditions guard, they are not considered alive automaticly. If all the statements is considered dead, they will all be replaced with a single skip.

After the transformation of the if-statement, the code will look like this:
\begin{lstlisting}
module dead_code_elimination_example :
	read d;
	read i;
	i := 2;
	a := a + 1;
	if i > d -> skip
	[] i = d -> i := a * 2; a := i * i
	[] i < d -> abort
	fi;
	write a
end
\end{lstlisting}
The next two lines before the if-sentence, they are both being considered alive, again because they have an effect on variables considered alive (a and i). For the read statements, the rules differs again. After the previous two assign statements, only a and d is considered alive (i is assigned, no variable have an effect on this assignment). No read statement can be removed, as the program will hold and wait for some input, even though the variable it writes the value to is considered dead.
